# -*- coding: utf-8 -*-
"""é»„é‡‘æŠ•èµ„AIå†³ç­–é›·è¾¾ä¸»ç¨‹åº

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18rc2MxNcmJ10cNhSQTUekRN0QpjRHRJw
"""

import streamlit as st
import yfinance as yf
import pandas as pd
import feedparser
from datetime import datetime

# --- Page Configuration ---
st.set_page_config(page_title="é»„é‡‘æŠ•èµ„ AI å†³ç­–å®¤", page_icon="ğŸ†", layout="wide")

# --- Core Logic: Data Retrieval (Cache 1 hour for hourly updates) ---
@st.cache_data(ttl=3600)
def get_financial_data():
    """Fetches key financial data (Gold, DXY, VIX, TNX) on a 1-hour interval for 1 month."""
    # Define assets to monitor
    tickers = {
        'é»„é‡‘ (Gold)': 'GC=F',
        'ç¾å…ƒæŒ‡æ•° (DXY)': 'DX-Y.NYB',
        '10å¹´ç¾å€ºæ”¶ç›Šç‡': '^TNX',
        'ææ…ŒæŒ‡æ•° (VIX)': '^VIX', # Geopolitical risk proxy
        'æ ‡æ™®500': '^GSPC'
    }

    data_store = {}

    # Download 1-month data with 1-hour intervals
    for name, symbol in tickers.items():
        try:
            # Use pre/post market data if available for continuous charting
            df = yf.download(symbol, period="1mo", interval="1h", progress=False, prepost=True)
            if not df.empty:
                data_store[name] = df
        except Exception as e:
            # Log the error but don't stop the app
            print(f"Failed to fetch {name} ({symbol}): {e}")

    return data_store

# --- Core Logic: News Scraping (Political/Macro) ---
@st.cache_data(ttl=3600)
def get_news():
    """Fetches recent financial news from RSS feeds."""
    rss_urls = [
        "https://search.cnbc.com/rs/search/combinedcms/view.xml?partnerId=wrss01&id=10000664", # CNBC Finance
        "https://feeds.content.dowjones.io/public/rss/mw_topstories" # Market Watch Top Stories
    ]
    news_items = []

    for url in rss_urls:
        try:
            feed = feedparser.parse(url)
            # Take the top 5 entries from each source
            for entry in feed.entries[:5]:
                # Convert time format if possible
                published_time = entry.get('published', 'åˆšåˆš')
                try:
                    # Attempt to parse common RSS date formats
                    dt = datetime.strptime(published_time, '%a, %d %b %Y %H:%M:%S %z')
                    published_time = dt.strftime('%Y-%m-%d %H:%M')
                except:
                    pass # Keep 'åˆšåˆš' or original string if parsing fails

                news_items.append({
                    'title': entry.title,
                    'link': entry.link,
                    'published': published_time
                })
        except Exception as e:
             print(f"Failed to fetch RSS from {url}: {e}")

    return news_items

# --- Core Logic: AI Scoring System with Robustness ---
def calculate_signal(data):
    """Calculates a numerical score and reasons based on financial data."""
    score = 0
    reasons = []

    # --- 1. Gold Technical Analysis (MA & RSI) ---
    gold_df = data.get('é»„é‡‘ (Gold)')
    if gold_df is not None and not gold_df.empty:
        current_price = gold_df['Close'].iloc[-1]
        gold_series = gold_df['Close']

        # 1.1 Moving Average (MA) Calculation with Fallback
        required_ma_points = 50
        fallback_period = 10

        if len(gold_series) >= required_ma_points:
            ma_value = gold_series.rolling(required_ma_points).mean().iloc[-1]
            ma_period = required_ma_points
        elif len(gold_series) >= fallback_period:
            ma_value = gold_series.rolling(fallback_period).mean().iloc[-1]
            ma_period = fallback_period
            reasons.append(f"âš ï¸ å‡çº¿å®¹é”™ï¼šæ•°æ®ä¸è¶³ {required_ma_points} å°æ—¶ï¼Œä½¿ç”¨ {fallback_period} å°æ—¶å‡çº¿è®¡ç®—ã€‚")
        else:
            # If even 10 points are not available, skip MA calculation
            ma_value = current_price # Default to current price to avoid division by zero/NaN issues
            ma_period = 0
            reasons.append("ğŸš« å‡çº¿è·³è¿‡ï¼šæ•°æ®ç‚¹å¤ªå°‘ï¼Œæ— æ³•è®¡ç®—ä»»ä½•å‡çº¿ã€‚")

        if ma_period > 0:
            if current_price > ma_value:
                score += 2
                reasons.append(f"ğŸ“ˆ æŠ€æœ¯é¢ï¼šé‡‘ä»·ä½äº{ma_period}å°æ—¶å‡çº¿ä¸Šæ–¹ (çœ‹æ¶¨)")
            else:
                score -= 2
                reasons.append(f"ğŸ“‰ æŠ€æœ¯é¢ï¼šé‡‘ä»·ä½äº{ma_period}å°æ—¶å‡çº¿ä¸‹æ–¹ (çœ‹è·Œ)")

        # 1.2 RSI Calculation (14-period) with Fallback
        required_rsi_points = 14
        rsi = None

        if len(gold_series) >= required_rsi_points:
            delta = gold_series.diff()
            gain = (delta.where(delta > 0, 0)).rolling(required_rsi_points).mean()
            loss = (-delta.where(delta < 0, 0)).rolling(required_rsi_points).mean()
            # Avoid division by zero when loss is 0
            rs = gain / loss.replace(0, 1e-10)
            rsi = 100 - (100 / (1 + rs)).iloc[-1]
        else:
            reasons.append("ğŸš« RSIè·³è¿‡ï¼šæ•°æ®ç‚¹å¤ªå°‘ï¼Œæ— æ³•è®¡ç®— RSI (éœ€14å°æ—¶)ã€‚")

        if rsi is not None and not pd.isna(rsi):
            reasons.append(f"ğŸ¯ å®æ—¶RSI (14H): {rsi:.2f}")
            if rsi < 30:
                score += 1
                reasons.append("âš¡ RSIæŒ‡æ ‡ï¼šè¿›å…¥è¶…å–åŒºé—´ (åå¼¹æ¦‚ç‡å¤§)")
            elif rsi > 70:
                score -= 1
                reasons.append("âš ï¸ RSIæŒ‡æ ‡ï¼šè¿›å…¥è¶…ä¹°åŒºé—´ (å›è°ƒé£é™©å¤§)")

    # --- 2. Macro Analysis (USD & VIX) ---

    # 2.1 USD Index (DXY)
    dxy_df = data.get('ç¾å…ƒæŒ‡æ•° (DXY)')
    if dxy_df is not None and len(dxy_df) >= 2:
        # Compare current to 24 hours ago (or first available point if less than 24)
        dxy_now = dxy_df['Close'].iloc[-1]

        # Try to get 24 hours ago, otherwise use the first point as comparison base
        idx_prev = -24 if len(dxy_df) >= 24 else 0
        dxy_prev = dxy_df['Close'].iloc[idx_prev]

        if dxy_now < dxy_prev:
            score += 2
            reasons.append(f"ğŸ’µ å®è§‚é¢ï¼šç¾å…ƒæŒ‡æ•° ({dxy_now:.2f}) æ—¥å†…ç›¸å¯¹èµ°å¼± (åˆ©å¥½é»„é‡‘)")
        else:
            score -= 2
            reasons.append(f"ğŸ’µ å®è§‚é¢ï¼šç¾å…ƒæŒ‡æ•° ({dxy_now:.2f}) æ—¥å†…ç›¸å¯¹èµ°å¼º (åˆ©ç©ºé»„é‡‘)")

    # 2.2 Volatility Index (VIX - Geopolitical/Fear Proxy)
    vix_df = data.get('ææ…ŒæŒ‡æ•° (VIX)')
    if vix_df is not None and not vix_df.empty:
        vix_now = vix_df['Close'].iloc[-1]
        reasons.append(f"ğŸ’£ ææ…ŒæŒ‡æ•°VIX: {vix_now:.2f}")
        if vix_now > 20: # High fear
            score += 2
            reasons.append("ğŸ’£ æƒ…ç»ªé¢ï¼šå¸‚åœºææ…ŒæŒ‡æ•°(VIX)è¾ƒé«˜ (é¿é™©èµ„é‡‘æµå…¥)")
        elif vix_now < 13: # Extreme complacency
            score -= 1
            reasons.append("ğŸ•Šï¸ æƒ…ç»ªé¢ï¼šå¸‚åœºæåº¦å¹³é™ (é¿é™©éœ€æ±‚ä½)")

    return score, reasons

# --- UI Rendering ---
def main():
    st.title("ğŸ¥‡ é»„é‡‘æŠ•èµ„ AI å†³ç­–å®¤")

    # Attempt to load data
    try:
        with st.spinner('æ­£åœ¨è¿æ¥å…¨çƒäº¤æ˜“æ‰€ä¸æ–°é—»æº...'):
            data = get_financial_data()
            news = get_news()

            # Check if essential data (Gold) is available
            if 'é»„é‡‘ (Gold)' not in data or data['é»„é‡‘ (Gold)'].empty:
                st.error("æ•°æ®æºè¿æ¥å¤±è´¥æˆ–å¸‚åœºä¼‘å¸‚ä¸­ã€‚è¯·ç¨åå†è¯•æˆ–æ£€æŸ¥å¸‚åœºçŠ¶æ€ã€‚")
                return

            score, reasons = calculate_signal(data)

            st.markdown(f"*æ•°æ®æ›´æ–°æ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} (æ¯å°æ—¶è‡ªåŠ¨åˆ·æ–°)*")

    except Exception as e:
        st.error(f"ç³»ç»Ÿå¯åŠ¨å¤±è´¥: {e}")
        st.stop()
        return

    # --- Sidebar ---
    with st.sidebar:
        st.header("å…³äºç³»ç»Ÿ")
        st.info("æœ¬ç³»ç»Ÿæ¯å°æ—¶æŠ“å–ç¾è”å‚¨åˆ©ç‡é¢„æœŸ(ç¾å€º)ã€å…¨çƒåœ°ç¼˜æ”¿æ²»ææ…Œåº¦(VIX)åŠç¾å…ƒèµ°åŠ¿ï¼Œç»¼åˆè®¡ç®—ä¹°å–ä¿¡å·ã€‚")
        st.caption("ç³»ç»Ÿä¾èµ– yfinance è·å–æ•°æ®ï¼Œå¯èƒ½å—å¸‚åœºé—­å¸‚å½±å“æ•°æ®é‡ã€‚")
        if st.button("ğŸ”„ æ‰‹åŠ¨å¼ºåˆ¶åˆ·æ–°æ•°æ®"):
            st.cache_data.clear()
            st.rerun()

    # --- 1. Core Decision Dashboard ---
    st.divider()
    col1, col2, col3 = st.columns([1, 2, 1])

    gold_df = data['é»„é‡‘ (Gold)']
    cur_gold = gold_df['Close'].iloc[-1]

    # Calculate difference for the metric
    if len(gold_df) >= 2:
        gold_delta = cur_gold - gold_df['Close'].iloc[-2]
    else:
        gold_delta = 0 # Not enough data for delta

    with col1:
        st.metric("å®æ—¶é‡‘ä»· (USD/oz)", f"${cur_gold:.2f}",
                  f"{gold_delta:.2f}")

    with col2:
        # Signal Display
        st.subheader("ğŸ¤– AI å»ºè®®")
        if score >= 4:
            st.success(f"â­â­â­â­ å¼ºçƒˆå»ºè®®ä¹°å…¥ (å¾—åˆ†: {score})")
        elif score >= 1:
            st.info(f"â­ åå¤šéœ‡è¡ / é€¢ä½åšå¤š (å¾—åˆ†: {score})")
        elif score <= -4:
            st.error(f"ğŸ”»ğŸ”»ğŸ”»ğŸ”» å¼ºçƒˆå»ºè®®å–å‡º / åšç©º (å¾—åˆ†: {score})")
        elif score < 0:
             st.warning(f"ğŸ”½ åç©ºéœ‡è¡ / é€¢é«˜åšç©º (å¾—åˆ†: {score})")
        else:
            st.warning(f"âœ‹ è§‚æœ› / ç­‰å¾…æ–¹å‘ (å¾—åˆ†: {score})")

    dxy_df = data.get('ç¾å…ƒæŒ‡æ•° (DXY)')
    if dxy_df is not None and not dxy_df.empty:
        cur_dxy = dxy_df['Close'].iloc[-1]
        if len(dxy_df) >= 2:
            dxy_delta = cur_dxy - dxy_df['Close'].iloc[-2]
        else:
             dxy_delta = 0

        with col3:
            st.metric("ç¾å…ƒæŒ‡æ•° DXY", f"{cur_dxy:.2f}",
                      f"{dxy_delta:.2f}", delta_color="inverse")
    else:
        with col3:
            st.metric("ç¾å…ƒæŒ‡æ•° DXY", "N/A", "N/A")

    # --- 2. Detailed Logic Display ---
    st.write("### ğŸ§  å†³ç­–ä¾æ®")
    for r in reasons:
        st.write(r)

    st.divider()

    # --- 3. Charts and News ---
    c1, c2 = st.columns(2)

    with c1:
        st.write("### ğŸ“Š é»„é‡‘ vs ç¾å…ƒèµ°åŠ¿ (æœ€è¿‘1å‘¨)")

        # Prepare data for charting (max 168 hours = 7 days)
        g_data = gold_df['Close'].tail(168)
        d_data = data.get('ç¾å…ƒæŒ‡æ•° (DXY)', pd.DataFrame())
        d_data = d_data['Close'].tail(168)

        if not g_data.empty and not d_data.empty:
            df_chart = pd.DataFrame()
            # Normalize for comparison: (Price - Mean) / Mean
            df_chart['Gold'] = (g_data - g_data.mean()) / g_data.mean()
            df_chart['USD'] = (d_data - d_data.mean()) / d_data.mean()

            # Align indices before plotting
            df_chart = df_chart.dropna()

            st.line_chart(df_chart)
            st.caption("æ³¨ï¼šæ•°æ®å·²å½’ä¸€åŒ–ã€‚é€šå¸¸ç¾å…ƒè·Œ(æ©™çº¿)ï¼Œé»„é‡‘æ¶¨(è“çº¿)ã€‚")
        else:
             st.warning("å›¾è¡¨æ•°æ®ä¸å®Œæ•´ï¼Œæ— æ³•æ˜¾ç¤ºé»„é‡‘ä¸ç¾å…ƒå¯¹æ¯”èµ°åŠ¿ã€‚")


    with c2:
        st.write("### ğŸŒ å…¨çƒå®è§‚/æ”¿æ²»å¿«è®¯")
        if news:
            for n in news:
                st.markdown(f"**[{n['title']}]({n['link']})**")
                st.caption(f"å‘å¸ƒæ—¶é—´: {n['published']}")
        else:
            st.info("æš‚æœªæŠ“å–åˆ°æœ€æ–°çš„å®è§‚æ–°é—»ã€‚")

if __name__ == "__main__":
    main()